https://github.com/user-attachments/assets/495f93c7-8659-4f16-bab5-1918bc38d36e


# سامانه مدیریت پرونده
<i>توجه: تمامی اطلاعات مراجعه کنندگان تستی هستند.</i><br>
یک سیستم مدیریت جامع که برای دیجیتالی کردن فرآیند ثبت سوابق مرکز مشاوره توسعه داده شده است.
این برنامه این امکان را می‌دهد که مراجعین را ثبت، شماره پرونده‌ها را به طور خودکار پیگیری و سابقه بیمار را از طریق یک رابط کاربری ساده و پاسخگو مدیریت کنند.<br>
ساختار پروژه فرانت اند:
```text
├── src/
│   ├── pages/
│   │   ├── DescriptionModal.tsx
│   │   ├── edit-modal.css
│   │   ├── EditModal.tsx
│   │   ├── form-page.css
│   │   ├── FormPage.tsx
│   │   ├── list-page.css
│   │   └── ListPage.tsx
│   ├── types/
│   │   ├── DescriptionModalProps.ts
│   │   ├── EditModalProps.ts
│   │   └── EditModalProps.ts
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   └── main.tsx
├── package.json
└── tsconfig.json
```
App.tsx: <br>
* برای جابه‌جایی بین صفحات، سراغ React Router v6 رفتم. سعی کردم صفحات رو کاملاً از هم تفکیک کنم (مثل مسیرهای / و /form و /list) تا اپلیکیشن ساختار شفاف‌تری داشته باشه.
* توی یک سیستم مدیریتی، خیلی مهم است که کاربر گم نشود و دقیقاً بداند در کدام بخش است. برای همین، یک سیستم ناوبری پویا طراحی کردم که وضعیت منوها را به صورت لحظه‌ای نشان می‌دهد.
* برای اینکه کاربر توی مسیرهای اشتباه بن‌بست نخوره و تجربه‌اش خراب نشه، یک مسیر Catch-All Route با استفاده از کاراکتر * پیاده‌سازی کردم.

ListPage.tsx: <br>
* وقتی تعداد داده‌ها زیاد می‌شود، لیست کردن همه شماره صفحات در پایین صفحه ظاهر برنامه را به‌هم می‌ریزد. برای حل این مشکل، یک منطق Dynamic Range پیاده‌سازی کردم که از سیستم سه‌نقطه (...) استفاده می‌کند.
* محاسبه پنجره مرکزی: با تعریف یک ثابت به نام MAX_VISIBLE_PAGES (حداکثر صفحات قابل مشاهده)، الگوریتم تصمیم می‌گیرد که چه زمانی صفحات اول و آخر را نشان دهد و چه زمانی صفحات میانی را برای خلوت شدن ظاهر کار، به سه‌نقطه تبدیل کند.
* در دنیای ری‌اکت، رندرهای اضافی (Re-renders) دشمن اصلی سرعت برنامه هستند. برای اینکه رابط کاربری نرم و روان باقی بماند، از هوک useMemo استفاده کردم.
* فیلتر هوشمند: لیست بازدیدکنندگان فقط زمانی دوباره فیلتر می‌شود که یا دیتای اصلی تغییر کند یا کلمه مورد جستجو. در بقیه مواقع، ری‌اکت نتیجه قبلی را از حافظه می‌خواند.
* نتیجه نهایی: این معماری باعث می‌شود حتی اگر هزاران ردیف دیتا داشته باشید، تایپ کردن در باکس جستجو کاملاً آنی (Instant) باشد؛ چون برنامه مجبور نیست با هر بار فشردن یک کلید، کل محاسبات را از اول انجام دهد.
* در این پروژه، تعامل با داده‌ها (ایجاد، ویرایش و حذف) طوری طراحی شده که کاربر همیشه به «آخرین نسخه واقعیت» دسترسی داشته باشد.
* بروزرسانی هوشمند: بعد از هر تغییر (مثل ویرایش با متد PUT یا حذف با DELETE)، سیستم بلافاصله یک واکشی مجدد (Re-fetch) در پس‌زمینه انجام می‌دهد. این کار باعث می‌شود دیتای روی صفحه همیشه با دیتای واقعیِ سمت سرور (Source of Truth) کاملاً همگام بماند.
* قفل‌های ایمنی: برای جلوگیری از فاجعه! از آنجایی که این داده‌ها حساس هستند، عملیات حذف را با دیالوگ‌های تاییدیه (Confirmation) محافظت کردم تا هیچ دیتایی با یک کلیک اشتباه از دست نرود.
* برای اینکه کدها شلوغ نشوند و اصل DRY (تکرار نکردن کد) رعایت شود، بخش‌های «مشاهده جزئیات» و «ویرایش» را به کامپوننت‌های کاملاً مجزا و تخصصی تقسیم کردم.
FormPage: <br>
* آماده‌سازی برای ورودی بعدی: به محض اینکه پیغام "موفقیت‌آمیز بود" از سرور برگردد، فرم به صورت خودکار خالی می‌شود. این‌طوری هم کاربر می‌فهمد که کارش تمام شده و هم لازم نیست برای ثبت نفر بعدی، صفحه را رفرش کند یا دستی فیلدها را پاک کند.
* هر حرفی که کاربر تایپ می‌کند، همان لحظه در حافظه برنامه (State) ثبت می‌شود.
* برای هر فیلد یک برچسب (Label) گذاشتم که به آن فیلد متصل است. این کار باعث می‌شود اگر کاربر حتی روی نوشته‌ی کنار فیلد هم کلیک کند، آن فیلد انتخاب شود. این موضوع برای راحتی کار با موبایل یا تبلت عالی است.
* راهنمای داخل کادر (Placeholder): داخل فیلدها مثال‌هایی زدم (مثلاً فرمت تاریخ شمسی) تا کاربر قبل از تایپ کردن، دقیقاً بداند که اطلاعات را باید با چه شکلی وارد کند و اشتباهی رخ ندهد.
EditModal: <br>
* یکی از چالش‌های کار با فرم‌های ویرایش این است که اگر کاربر وسط کار پشیمان شود، نباید دیتای اصلی تغییر کرده باشد. برای حل این مشکل، از الگوی حافظه موقت استفاده کردم.
* وقتی مدال ویرایش باز می‌شود، یک کپی از اطلاعات اصلی در حافظه موقت فرم ساخته می‌شود. تمام تغییرات کاربر روی این کپی انجام می‌شود. اگر کاربر دکمه انصراف را بزند، دیتای اصلی لیست دست‌نخورده باقی می‌ماند و هیچ دیتای ناقصی وارد سیستم نمی‌شود.
* با استفاده از useEffect کاری کردم که اگر به هر دلیلی دیتای اصلی (در حالی که مدال باز است) تغییر کرد، حافظه موقت فرم هم بلافاصله خودش را بروز کند تا همیشه آخرین اطلاعات نمایش داده شود.
* از تکنیک stopPropagation استفاده کردم تا وقتی کاربر روی خودِ فرم یا دکمه‌های داخل مدال کلیک می‌کند، پنجره به اشتباه بسته نشود. در واقع کلیک‌های داخل فرم را از کلیک‌های بیرون آن جدا کردم.
* طبق استاندارد برنامه‌های حرفه‌ای، قابلیتی گذاشتم که کاربر با کلیک روی فضای خالی اطراف مدال (Backdrop)، بتواند آن را ببندد. این‌طوری دیگر نیازی نیست کاربر حتماً دنبال یک دکمه ضربدر کوچک بگردد و کار با برنامه سریع‌تر و راحت‌تر می‌شود.
* قبل از اینکه دیتای فرم به سمت سرور فرستاده شود، یک لایه بررسی (Validation) قرار دادم تا مطمئن شوم اطلاعات ناقص یا خراب وارد دیتابیس نمی‌شوند.
DescriptionModal: <br>
* این کامپوننت فقط از طریق ورودی‌ها (Props) دیتا می‌گیرد، رفتار آن کاملاً پیش‌بینی‌پذیر است. این موضوع باعث می‌شود پیدا کردن باگ‌ها و استفاده مجدد از این کد در بخش‌های دیگر پروژه بسیار راحت باشد.
* یک سیستم جایگزین هوشمند طراحی کردم که اگر بازدیدی توضیحات نداشت، به جای خالی ماندن یا به هم ریختن صفحه، علامت «---» را نشان دهد. این کار باعث می‌شود ظاهر برنامه همیشه حرفه‌ای و مرتب باقی بماند.
* با استفاده از تکنیک stopPropagation کاری کردم که اگر کاربر بخواهد متن توضیحات را با موس انتخاب یا کپی کند، پنجره به اشتباه بسته نشود. در واقع، ویژگی «بستن با کلیک روی حاشیه» فقط زمانی عمل می‌کند که کاربر واقعاً روی فضای خالی بیرونِ کادر کلیک کرده باشد.
* از آنجایی که یادداشت‌های مربوط به هر بازدیدکننده ممکن است خیلی طولانی باشد، ساختار نمایش را طوری طراحی کردم که هم برای چشم خسته نشود و هم کد برنامه سبک باقی بماند.
* در بالای پنجره نمایش، نام بازدیدکننده را قرار دادم. این کار باعث می‌شود کاربر در هر لحظه بداند دقیقاً دارد پرونده‌ی چه کسی را مطالعه می‌کند و تمرکزش را از دست ندهد.
* به جای اینکه برای هر بخش یک فایل استایل جدید و سنگین بسازم، از کدهای قبلی (مثل چیدمان مدال ویرایش) دوباره استفاده کردم. با این روش، حجم فایل‌های CSS برنامه کمتر شده و سرعت لود شدن بالاتر می‌رود، در حالی که ظاهر هر بخش همچنان اختصاصی و مرتب است. <br>
ساختار بک اند:  <br>
```text
├── backend/
├── data.json
└── server.js
```
data.json: <br>
```text
[
  {
    "name": "محمد رضائی",
    "creationDate": "1403/10/26",
    "phone": "09112223311",
    "description": "مشاوره کودک پرتحرک",
    "id": 1765379045099,
    "caseNumber": 99
  }
.
.
.
]
```
server.js: <br>
* سرور را طوری برنامه‌نویسی کردم که در لحظه‌ی اجرا، خودش سلامت فایل داده‌ها را چک کند. اگر فایل data.json وجود نداشته باشد یا آسیب دیده باشد، سرور به جای از کار افتادن (Crash)، خودش یک فایل جدید و سالم می‌سازد. این کار باعث می‌شود اولین نصب و اجرای پروژه بدون هیچ خطایی انجام شود.
* به جای اینکه فقط تعداد کل کاربران را بشمارم (که با حذف یک نفر باگ ایجاد می‌کند)، از تابع reduce استفاده کردم. برنامه ابتدا بزرگترین شماره پرونده موجود را پیدا می‌کند و سپس عدد ۱ را به آن اضافه می‌کند. این کار باعث می‌شود حتی اگر پرونده‌ای از وسط لیست حذف شود، شماره پرونده‌های جدید همچنان منحصربه‌فرد و مرتب باقی بمانند.
* برای شناسه‌های داخلی سیستم از Date.now() استفاده کردم. این کار تضمین می‌کند که هر رکورد یک امضای زمانی کاملاً اختصاصی داشته باشد و هیچ دو رکوردی (حتی اگر همزمان ثبت شوند) با هم تداخل پیدا نکنند.
bat file: <br>
* برای اینکه اجرای پروژه برای توسعه‌دهندگان تا حد ممکن ساده شود، یک اسکریپت اتوماسیون طراحی کردم که تمام مراحل راه‌اندازی فرانت‌بند و بک‌بند را به صورت خودکار و تنها با یک دستور انجام می‌دهد.






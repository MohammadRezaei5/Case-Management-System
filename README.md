# سامانه مدیریت پرونده
یک سیستم مدیریت جامع که برای دیجیتالی کردن فرآیند ثبت سوابق مرکز مشاوره توسعه داده شده است.
این برنامه این امکان را می‌دهد که مراجعین را ثبت، شماره پرونده‌ها را به طور خودکار پیگیری و سابقه بیمار را از طریق یک رابط کاربری ساده و پاسخگو مدیریت کنند.<br>
ساختار پروژه فرانت اند:
```text
├── src/
│   ├── pages/
│   │   ├── DescriptionModal.tsx
│   │   ├── edit-modal.css
│   │   ├── EditModal.tsx
│   │   ├── form-page.css
│   │   ├── FormPage.tsx
│   │   ├── list-page.css
│   │   └── ListPage.tsx
│   ├── types/
│   │   ├── DescriptionModalProps.ts
│   │   ├── EditModalProps.ts
│   │   └── EditModalProps.ts
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   └── main.tsx
├── package.json
└── tsconfig.json
```
App.tsx: <br>
* برای جابه‌جایی بین صفحات، سراغ React Router v6 رفتم. سعی کردم صفحات رو کاملاً از هم تفکیک کنم (مثل مسیرهای / و /form و /list) تا اپلیکیشن ساختار شفاف‌تری داشته باشه.
* توی یک سیستم مدیریتی، خیلی مهم است که کاربر گم نشود و دقیقاً بداند در کدام بخش است. برای همین، یک سیستم ناوبری پویا طراحی کردم که وضعیت منوها را به صورت لحظه‌ای نشان می‌دهد.
* برای اینکه کاربر توی مسیرهای اشتباه بن‌بست نخوره و تجربه‌اش خراب نشه، یک مسیر Catch-All Route با استفاده از کاراکتر * پیاده‌سازی کردم.

ListPage.tsx: <br>
* وقتی تعداد داده‌ها زیاد می‌شود، لیست کردن همه شماره صفحات در پایین صفحه ظاهر برنامه را به‌هم می‌ریزد. برای حل این مشکل، یک منطق Dynamic Range پیاده‌سازی کردم که از سیستم سه‌نقطه (...) استفاده می‌کند.
* محاسبه پنجره مرکزی: با تعریف یک ثابت به نام MAX_VISIBLE_PAGES (حداکثر صفحات قابل مشاهده)، الگوریتم تصمیم می‌گیرد که چه زمانی صفحات اول و آخر را نشان دهد و چه زمانی صفحات میانی را برای خلوت شدن ظاهر کار، به سه‌نقطه تبدیل کند.
* در دنیای ری‌اکت، رندرهای اضافی (Re-renders) دشمن اصلی سرعت برنامه هستند. برای اینکه رابط کاربری نرم و روان باقی بماند، از هوک useMemo استفاده کردم.
* فیلتر هوشمند: لیست بازدیدکنندگان فقط زمانی دوباره فیلتر می‌شود که یا دیتای اصلی تغییر کند یا کلمه مورد جستجو. در بقیه مواقع، ری‌اکت نتیجه قبلی را از حافظه می‌خواند.
* نتیجه نهایی: این معماری باعث می‌شود حتی اگر هزاران ردیف دیتا داشته باشید، تایپ کردن در باکس جستجو کاملاً آنی (Instant) باشد؛ چون برنامه مجبور نیست با هر بار فشردن یک کلید، کل محاسبات را از اول انجام دهد.
* در این پروژه، تعامل با داده‌ها (ایجاد، ویرایش و حذف) طوری طراحی شده که کاربر همیشه به «آخرین نسخه واقعیت» دسترسی داشته باشد.
* بروزرسانی هوشمند: بعد از هر تغییر (مثل ویرایش با متد PUT یا حذف با DELETE)، سیستم بلافاصله یک واکشی مجدد (Re-fetch) در پس‌زمینه انجام می‌دهد. این کار باعث می‌شود دیتای روی صفحه همیشه با دیتای واقعیِ سمت سرور (Source of Truth) کاملاً همگام بماند.
* قفل‌های ایمنی: برای جلوگیری از فاجعه! از آنجایی که این داده‌ها حساس هستند، عملیات حذف را با دیالوگ‌های تاییدیه (Confirmation) محافظت کردم تا هیچ دیتایی با یک کلیک اشتباه از دست نرود.
* برای اینکه کدها شلوغ نشوند و اصل DRY (تکرار نکردن کد) رعایت شود، بخش‌های «مشاهده جزئیات» و «ویرایش» را به کامپوننت‌های کاملاً مجزا و تخصصی تقسیم کردم.
FormPage: <br>
* آماده‌سازی برای ورودی بعدی: به محض اینکه پیغام "موفقیت‌آمیز بود" از سرور برگردد، فرم به صورت خودکار خالی می‌شود. این‌طوری هم کاربر می‌فهمد که کارش تمام شده و هم لازم نیست برای ثبت نفر بعدی، صفحه را رفرش کند یا دستی فیلدها را پاک کند.
* هر حرفی که کاربر تایپ می‌کند، همان لحظه در حافظه برنامه (State) ثبت می‌شود.
* برای هر فیلد یک برچسب (Label) گذاشتم که به آن فیلد متصل است. این کار باعث می‌شود اگر کاربر حتی روی نوشته‌ی کنار فیلد هم کلیک کند، آن فیلد انتخاب شود. این موضوع برای راحتی کار با موبایل یا تبلت عالی است.
* راهنمای داخل کادر (Placeholder): داخل فیلدها مثال‌هایی زدم (مثلاً فرمت تاریخ شمسی) تا کاربر قبل از تایپ کردن، دقیقاً بداند که اطلاعات را باید با چه شکلی وارد کند و اشتباهی رخ ندهد.
EditModal:
* یکی از چالش‌های کار با فرم‌های ویرایش این است که اگر کاربر وسط کار پشیمان شود، نباید دیتای اصلی تغییر کرده باشد. برای حل این مشکل، از الگوی حافظه موقت استفاده کردم.
* وقتی مدال ویرایش باز می‌شود، یک کپی از اطلاعات اصلی در حافظه موقت فرم ساخته می‌شود. تمام تغییرات کاربر روی این کپی انجام می‌شود. اگر کاربر دکمه انصراف را بزند، دیتای اصلی لیست دست‌نخورده باقی می‌ماند و هیچ دیتای ناقصی وارد سیستم نمی‌شود.
* با استفاده از useEffect کاری کردم که اگر به هر دلیلی دیتای اصلی (در حالی که مدال باز است) تغییر کرد، حافظه موقت فرم هم بلافاصله خودش را بروز کند تا همیشه آخرین اطلاعات نمایش داده شود.
* از تکنیک stopPropagation استفاده کردم تا وقتی کاربر روی خودِ فرم یا دکمه‌های داخل مدال کلیک می‌کند، پنجره به اشتباه بسته نشود. در واقع کلیک‌های داخل فرم را از کلیک‌های بیرون آن جدا کردم.
* طبق استاندارد برنامه‌های حرفه‌ای، قابلیتی گذاشتم که کاربر با کلیک روی فضای خالی اطراف مدال (Backdrop)، بتواند آن را ببندد. این‌طوری دیگر نیازی نیست کاربر حتماً دنبال یک دکمه ضربدر کوچک بگردد و کار با برنامه سریع‌تر و راحت‌تر می‌شود.
* قبل از اینکه دیتای فرم به سمت سرور فرستاده شود، یک لایه بررسی (Validation) قرار دادم تا مطمئن شوم اطلاعات ناقص یا خراب وارد دیتابیس نمی‌شوند.







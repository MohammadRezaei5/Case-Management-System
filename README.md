# سامانه مدیریت پرونده
یک سیستم مدیریت جامع که برای دیجیتالی کردن فرآیند ثبت سوابق مرکز مشاوره توسعه داده شده است.
این برنامه این امکان را می‌دهد که مراجعین را ثبت، شماره پرونده‌ها را به طور خودکار پیگیری و سابقه بیمار را از طریق یک رابط کاربری ساده و پاسخگو مدیریت کنند.<br>
ساختار پروژه فرانت اند:
```text
├── src/
│   ├── pages/
│   │   ├── DescriptionModal.tsx
│   │   ├── edit-modal.css
│   │   ├── EditModal.tsx
│   │   ├── form-page.css
│   │   ├── FormPage.tsx
│   │   ├── list-page.css
│   │   └── ListPage.tsx
│   ├── types/
│   │   ├── DescriptionModalProps.ts
│   │   ├── EditModalProps.ts
│   │   └── EditModalProps.ts
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   └── main.tsx
├── package.json
└── tsconfig.json
```
App.tsx: <br>
* برای جابه‌جایی بین صفحات، سراغ React Router v6 رفتم. سعی کردم صفحات رو کاملاً از هم تفکیک کنم (مثل مسیرهای / و /form و /list) تا اپلیکیشن ساختار شفاف‌تری داشته باشه.
* توی یک سیستم مدیریتی، خیلی مهم است که کاربر گم نشود و دقیقاً بداند در کدام بخش است. برای همین، یک سیستم ناوبری پویا طراحی کردم که وضعیت منوها را به صورت لحظه‌ای نشان می‌دهد.
* برای اینکه کاربر توی مسیرهای اشتباه بن‌بست نخوره و تجربه‌اش خراب نشه، یک مسیر Catch-All Route با استفاده از کاراکتر * پیاده‌سازی کردم.

ListPage.tsx: <br>
* وقتی تعداد داده‌ها زیاد می‌شود، لیست کردن همه شماره صفحات در پایین صفحه ظاهر برنامه را به‌هم می‌ریزد. برای حل این مشکل، یک منطق Dynamic Range پیاده‌سازی کردم که از سیستم سه‌نقطه (...) استفاده می‌کند.
* محاسبه پنجره مرکزی: با تعریف یک ثابت به نام MAX_VISIBLE_PAGES (حداکثر صفحات قابل مشاهده)، الگوریتم تصمیم می‌گیرد که چه زمانی صفحات اول و آخر را نشان دهد و چه زمانی صفحات میانی را برای خلوت شدن ظاهر کار، به سه‌نقطه تبدیل کند.
* در دنیای ری‌اکت، رندرهای اضافی (Re-renders) دشمن اصلی سرعت برنامه هستند. برای اینکه رابط کاربری نرم و روان باقی بماند، از هوک useMemo استفاده کردم.
* فیلتر هوشمند: لیست بازدیدکنندگان فقط زمانی دوباره فیلتر می‌شود که یا دیتای اصلی تغییر کند یا کلمه مورد جستجو. در بقیه مواقع، ری‌اکت نتیجه قبلی را از حافظه می‌خواند.
* نتیجه نهایی: این معماری باعث می‌شود حتی اگر هزاران ردیف دیتا داشته باشید، تایپ کردن در باکس جستجو کاملاً آنی (Instant) باشد؛ چون برنامه مجبور نیست با هر بار فشردن یک کلید، کل محاسبات را از اول انجام دهد.
* در این پروژه، تعامل با داده‌ها (ایجاد، ویرایش و حذف) طوری طراحی شده که کاربر همیشه به «آخرین نسخه واقعیت» دسترسی داشته باشد.
* بروزرسانی هوشمند: بعد از هر تغییر (مثل ویرایش با متد PUT یا حذف با DELETE)، سیستم بلافاصله یک واکشی مجدد (Re-fetch) در پس‌زمینه انجام می‌دهد. این کار باعث می‌شود دیتای روی صفحه همیشه با دیتای واقعیِ سمت سرور (Source of Truth) کاملاً همگام بماند.
* قفل‌های ایمنی: برای جلوگیری از فاجعه! از آنجایی که این داده‌ها حساس هستند، عملیات حذف را با دیالوگ‌های تاییدیه (Confirmation) محافظت کردم تا هیچ دیتایی با یک کلیک اشتباه از دست نرود.
* برای اینکه کدها شلوغ نشوند و اصل DRY (تکرار نکردن کد) رعایت شود، بخش‌های «مشاهده جزئیات» و «ویرایش» را به کامپوننت‌های کاملاً مجزا و تخصصی تقسیم کردم.






